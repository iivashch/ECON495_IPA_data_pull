# -*- coding: utf-8 -*-
"""API Data Pull.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19DkjG8bTr1sI4a0WaZZHZE5iUdhXp0QB

**Inflation for EU countries**
"""

import requests
import pandas as pd

# Your FRED API key
api_key = 'd726692257f21447103600d913230b26'  # Replace with your actual FRED API key

countries = {
    'Denmark': 'CPALTT01DKQ657N',
    'Finland': 'CPALTT01FIQ657N',
    'Sweden': 'CPALTT01SEQ657N',
    'Hungary': 'CPALTT01HUM657N',
    'Slovakia': 'CPALTT01SKQ657N',
    'Czech Republic': 'CPALTT01CZQ657N',
    'Poland': 'CPALTT01PLQ657N'
}

def fetch_fred_data(series_id, api_key):
    url = f'https://api.stlouisfed.org/fred/series/observations?series_id={series_id}&api_key={api_key}&file_type=json&frequency=q'
    response = requests.get(url)
    response.raise_for_status()  # Raise an error for bad status codes
    data = response.json()
    return data['observations']

data_frames = []

for country, series_id in countries.items():
    observations = fetch_fred_data(series_id, api_key)
    df = pd.DataFrame(observations)
    df['country'] = country
    data_frames.append(df[['date', 'value', 'country']])

# Combine all data frames into a single data frame
combined_df = pd.concat(data_frames)

# Save to a CSV file
combined_df.to_csv('inflation_data.csv', index=False)

print("Data has been saved to inflation_data.csv")

"""**Harmonized Gas Prices from FRED**"""

import requests
import pandas as pd

# Your FRED API key
api_key = 'd726692257f21447103600d913230b26'  # Replace with your actual FRED API key

countries = {
    'Denmark': 'CP0452DKM086NEST',
    'Finland': 'CP0452FIM086NEST',
    'Sweden': 'CP0452SEM086NEST',
    'Hungary': 'CP0452HUM086NEST',
    'Slovakia': 'CP0452SKM086NEST',
    'Czechia': 'CP0452CZM086NEST',
    'Poland': 'CP0452PLM086NEST'
}

def fetch_fred_data(series_id, api_key):
    url = f'https://api.stlouisfed.org/fred/series/observations?series_id={series_id}&api_key={api_key}&file_type=json&frequency=q'
    response = requests.get(url)
    response.raise_for_status()  # Raise an error for bad status codes
    data = response.json()
    return data['observations']

def convert_to_quarter_format(date_str):
    date = pd.to_datetime(date_str)
    quarter = (date.month - 1) // 3 + 1
    return f"{quarter}-{date.year}"

data_frames = []

for country, series_id in countries.items():
    observations = fetch_fred_data(series_id, api_key)
    df = pd.DataFrame(observations)
    df['country'] = country
    df['date'] = df['date'].apply(convert_to_quarter_format)
    df['key'] = df['country'] + df['date']
    data_frames.append(df[['date', 'country', 'key', 'value']])

# Combine all data frames into a single data frame
combined_df = pd.concat(data_frames)

# Save to a CSV file
combined_df.to_csv('harmonized_gas_price_index.csv', index=False)

print("Data has been saved to harmonized_gas_price_index.csv")

"""Testing unemployment assumptions"""

import requests
import pandas as pd

# Your FRED API key
api_key = 'd726692257f21447103600d913230b26'  # Replace with your actual FRED API key

indicies = {
    'Brent_Crude_Oil': 'POILBREUSDM',
    'Natural_Gas': 'PNGASEUUSDM',
    'Short_Term_Interest_Rate': 'IR3TIB01EZM156N',
    'Unemployment_Rate_EU': 'LRHUTTTTEUM156S',
    'Consumer Price Index' : 'EU28CPALTT01GYM'
}

def fetch_fred_data(series_id, api_key):
    url = f'https://api.stlouisfed.org/fred/series/observations'
    params = {
        'series_id': series_id,
        'api_key': api_key,
        'file_type': 'json',
        'frequency': 'm'  # monthly data
    }
    response = requests.get(url, params=params)
    response.raise_for_status()  # Raise an error for bad status codes
    data = response.json()
    return data['observations']

data_frames = []

for index, series_id in indicies.items():
    observations = fetch_fred_data(series_id, api_key)
    df = pd.DataFrame(observations)
    df['series'] = index
    data_frames.append(df[['date', 'value', 'series']])

# Combine all data frames into a single data frame
combined_df = pd.concat(data_frames)

# Convert the 'value' column to numeric, errors='coerce' will handle errors by setting invalid parsing as NaN
combined_df['value'] = pd.to_numeric(combined_df['value'], errors='coerce')

# Convert the 'date' column to datetime
combined_df['date'] = pd.to_datetime(combined_df['date'])

# Pivot the DataFrame to get series as columns
df_pivot = combined_df.pivot(index='date', columns='series', values='value')

# Sort by date
df_pivot.sort_index(inplace=True)

# Save to a CSV file
df_pivot.to_csv('economic_data.csv', na_rep='')  # na_rep='' to represent missing values as blanks

print("Data has been saved to economic_data.csv")

"""Testing Assumptions for Sweden

"""

import requests
import pandas as pd

# Your FRED API key
api_key = 'd726692257f21447103600d913230b26'  # Replace with your actual FRED API key

indicies = {
    'Brent_Crude_Oil': 'POILBREUSDM',
    'Natural_Gas': 'PNGASEUUSDM',
    'Short_Term_Interest_Rate Sweden': 'IR3TIB01SEM156N',
    'Unemployment_Rate Sweden': 'LRHUTTTTSEM156S',
    'Consumer Price Index Sweden' : 'CPALTT01SEM659N'
}

def fetch_fred_data(series_id, api_key):
    url = f'https://api.stlouisfed.org/fred/series/observations'
    params = {
        'series_id': series_id,
        'api_key': api_key,
        'file_type': 'json',
        'frequency': 'm'  # monthly data
    }
    response = requests.get(url, params=params)
    response.raise_for_status()  # Raise an error for bad status codes
    data = response.json()
    return data['observations']

data_frames = []

for index, series_id in indicies.items():
    observations = fetch_fred_data(series_id, api_key)
    df = pd.DataFrame(observations)
    df['series'] = index
    data_frames.append(df[['date', 'value', 'series']])

# Combine all data frames into a single data frame
combined_df = pd.concat(data_frames)

# Convert the 'value' column to numeric, errors='coerce' will handle errors by setting invalid parsing as NaN
combined_df['value'] = pd.to_numeric(combined_df['value'], errors='coerce')

# Convert the 'date' column to datetime
combined_df['date'] = pd.to_datetime(combined_df['date'])

# Pivot the DataFrame to get series as columns
df_pivot = combined_df.pivot(index='date', columns='series', values='value')

# Sort by date
df_pivot.sort_index(inplace=True)

# Save to a CSV file
df_pivot.to_csv('economic_data_sweden.csv', na_rep='')  # na_rep='' to represent missing values as blanks

print("Data has been saved to economic_data_sweden.csv")

"""Running a regression"""



import pandas as pd
import statsmodels.api as sm

# Read the CSV file
df = pd.read_csv('economic_data.csv')

df = df.dropna()

# If 'Date' column exists and we want to use it as a time index, parse the dates
df['date'] = pd.to_datetime(df['date'])
df.set_index('date', inplace=True)

# Define the independent variables (X) and the dependent variable (Y)
X = df[['Brent_Crude_Oil', 'Natural_Gas','Short_Term_Interest_Rate', 'Consumer Price Index']]  # Independent variables
Y = df['Unemployment_Rate_EU']           # Dependent variable

# Add a constant to the independent variables matrix (for the intercept term)
X = sm.add_constant(X)

# Fit the regression model
model = sm.OLS(Y, X).fit()

# Print the summary of the model
print(model.summary())

import pandas as pd
import statsmodels.api as sm

# Read the CSV file
df = pd.read_csv('economic_data.csv')

df = df.dropna()

# If 'Date' column exists and we want to use it as a time index, parse the dates
df['date'] = pd.to_datetime(df['date'])
df.set_index('date', inplace=True)

# Define the independent variables (X) and the dependent variable (Y)
X = df[['Brent_Crude_Oil', 'Natural_Gas','Short_Term_Interest_Rate']]  # Independent variables
Y = df['Consumer Price Index']           # Dependent variable

# Add a constant to the independent variables matrix (for the intercept term)
X = sm.add_constant(X)

# Fit the regression model
model = sm.OLS(Y, X).fit()

# Print the summary of the model
print(model.summary())

import pandas as pd
import statsmodels.api as sm

# Read the CSV file
df = pd.read_csv('economic_data_sweden.csv')

df = df.dropna()

# If 'Date' column exists and we want to use it as a time index, parse the dates
df['date'] = pd.to_datetime(df['date'])
df.set_index('date', inplace=True)

# Define the independent variables (X) and the dependent variable (Y)
X = df[['Brent_Crude_Oil', 'Natural_Gas','Short_Term_Interest_Rate Sweden', 'Consumer Price Index Sweden']]  # Independent variables
Y = df['Unemployment_Rate Sweden']           # Dependent variable

# Add a constant to the independent variables matrix (for the intercept term)
X = sm.add_constant(X)

# Fit the regression model
model = sm.OLS(Y, X).fit()

# Print the summary of the model
print(model.summary())

import pandas as pd
import statsmodels.api as sm

# Read the CSV file
df = pd.read_csv('economic_data_sweden.csv')

df = df.dropna()

# If 'Date' column exists and we want to use it as a time index, parse the dates
df['date'] = pd.to_datetime(df['date'])
df.set_index('date', inplace=True)

# Define the independent variables (X) and the dependent variable (Y)
X = df[['Brent_Crude_Oil', 'Natural_Gas','Short_Term_Interest_Rate Sweden']]  # Independent variables
Y = df['Consumer Price Index Sweden']           # Dependent variable

# Add a constant to the independent variables matrix (for the intercept term)
X = sm.add_constant(X)

# Fit the regression model
model = sm.OLS(Y, X).fit()

# Print the summary of the model
print(model.summary())

import pandas as pd
import statsmodels.api as sm

# Read the CSV file
df = pd.read_csv('economic_data_sweden.csv')

df = df.dropna()

# If 'Date' column exists and we want to use it as a time index, parse the dates
df['date'] = pd.to_datetime(df['date'])
df.set_index('date', inplace=True)

# Define the independent variables (X) and the dependent variable (Y)
X = df[['Consumer Price Index Sweden']]  # Independent variables
Y = df['Unemployment_Rate Sweden']           # Dependent variable

# Add a constant to the independent variables matrix (for the intercept term)
X = sm.add_constant(X)

# Fit the regression model
model = sm.OLS(Y, X).fit()

# Print the summary of the model
print(model.summary())

import pandas as pd
import statsmodels.api as sm

# Read the CSV file
df = pd.read_csv('economic_data_sweden.csv')

df = df.dropna()

# If 'Date' column exists and we want to use it as a time index, parse the dates
df['date'] = pd.to_datetime(df['date'])
df.set_index('date', inplace=True)

# Define the independent variables (X) and the dependent variable (Y)
X = df[['Brent_Crude_Oil', 'Natural_Gas','Short_Term_Interest_Rate Sweden']]  # Independent variables
Y = df['Consumer Price Index Sweden']           # Dependent variable

# Add a constant to the independent variables matrix (for the intercept term)
X = sm.add_constant(X)

# Fit the regression model
model = sm.OLS(Y, X).fit()

# Print the summary of the model
print(model.summary())

"""FRED Pull: Gas Prices, Short Term Interest Rate, Inflation"""

import requests
import pandas as pd

# Your FRED API key
api_key = 'd726692257f21447103600d913230b26'  # Replace with your actual FRED API key

# Series IDs for additional variables
# These are hypothetical series IDs and should be replaced with actual IDs from FRED
countries = {
    'Denmark': {
        'gas_price_index': 'CP0452DKM086NEST',
        'short_term_interest_rate': 'IR3TIB01DKM156N',
        'inflation': 'CPGRLE01DKM659N'
    },
    'Finland': {
        'gas_price_index': 'CP0452FIM086NEST',
        'short_term_interest_rate': 'IR3TIB01FIM156N',
        'inflation': 'CPGRLE01FIM659N'
    },
    'Sweden': {
        'gas_price_index': 'CP0452SEM086NEST',
        'short_term_interest_rate': 'IR3TIB01SEM156N',
        'inflation': 'CPGRLE01SEM659N'
    },
    'Hungary': {
        'gas_price_index': 'CP0452HUM086NEST',
        'short_term_interest_rate': 'IR3TIB01HUM156N',
        'inflation': 'CPGRLE01HUM659N'
    },
    'Slovakia': {
        'gas_price_index': 'CP0452SKM086NEST',
        'short_term_interest_rate': 'IR3TIB01SKM156N',
        'inflation': 'CPGRLE01SKM659N'
    },
    'Czechia': {
        'gas_price_index': 'CP0452CZM086NEST',
        'short_term_interest_rate': 'IR3TIB01CZM156N',
        'inflation': 'CPGRLE01CZM659N'
    },
    'Poland': {
        'gas_price_index': 'CP0452PLM086NEST',
        'short_term_interest_rate': 'IR3TIB01PLM156N',
        'inflation': 'CPGRLE01PLM659N'
    }
}

def fetch_fred_data(series_id, api_key):
    url = f'https://api.stlouisfed.org/fred/series/observations?series_id={series_id}&api_key={api_key}&file_type=json&frequency=q'
    response = requests.get(url)
    response.raise_for_status()  # Raise an error for bad status codes
    data = response.json()
    return data['observations']

def convert_to_quarter_format(date_str):
    date = pd.to_datetime(date_str)
    quarter = (date.month - 1) // 3 + 1
    return f"{quarter}-{date.year}"

combined_data = []

for country, series in countries.items():
    country_data = {'Country': country}

    # Fetch and process data for gas price index
    gas_price_observations = fetch_fred_data(series['gas_price_index'], api_key)
    gas_price_df = pd.DataFrame(gas_price_observations)
    gas_price_df['date'] = gas_price_df['date'].apply(convert_to_quarter_format)
    gas_price_df.rename(columns={'value': 'gas_price_index'}, inplace=True)

    # Fetch and process data for short term interest rate
    stir_observations = fetch_fred_data(series['short_term_interest_rate'], api_key)
    stir_df = pd.DataFrame(stir_observations)
    stir_df['date'] = stir_df['date'].apply(convert_to_quarter_format)
    stir_df.rename(columns={'value': 'short_term_interest_rate'}, inplace=True)

    # Fetch and process data for inflation
    inflation_observations = fetch_fred_data(series['inflation'], api_key)
    inflation_df = pd.DataFrame(inflation_observations)
    inflation_df['date'] = inflation_df['date'].apply(convert_to_quarter_format)
    inflation_df.rename(columns={'value': 'inflation'}, inplace=True)

    # Merge dataframes on country and date
    merged_df = gas_price_df.merge(stir_df, on='date').merge(inflation_df, on='date')
    merged_df['country'] = country

    combined_data.append(merged_df)

# Combine all data frames into a single data frame
combined_df = pd.concat(combined_data)

# Reorder and rename columns for clarity
combined_df = combined_df[['date', 'country', 'gas_price_index', 'short_term_interest_rate', 'inflation']]

# Save to a CSV file
combined_df.to_csv('full_country_monthly_economic_data.csv', index=False)

print("Data has been saved to full_country_monthly_economic_data.csv")

import requests
import pandas as pd

# Your FRED API key
api_key = 'd726692257f21447103600d913230b26'  # Replace with your actual FRED API key

# Series IDs for additional variables
# These are hypothetical series IDs and should be replaced with actual IDs from FRED
countries = {
    'Denmark': {
        'gas_price_index': 'CP0452DKM086NEST',
        'short_term_interest_rate': 'IR3TIB01DKM156N',
        'inflation': 'CPGRLE01DKM659N'
    },
    'Finland': {
        'gas_price_index': 'CP0452FIM086NEST',
        'short_term_interest_rate': 'IR3TIB01FIM156N',
        'inflation': 'CPGRLE01FIM659N'
    },
    'Sweden': {
        'gas_price_index': 'CP0452SEM086NEST',
        'short_term_interest_rate': 'IR3TIB01SEM156N',
        'inflation': 'CPGRLE01SEM659N'
    },
    'Hungary': {
        'gas_price_index': 'CP0452HUM086NEST',
        'short_term_interest_rate': 'IR3TIB01HUM156N',
        'inflation': 'CPGRLE01HUM659N'
    },
    'Slovakia': {
        'gas_price_index': 'CP0452SKM086NEST',
        'short_term_interest_rate': 'IR3TIB01SKM156N',
        'inflation': 'CPGRLE01SKM659N'
    },
    'Czechia': {
        'gas_price_index': 'CP0452CZM086NEST',
        'short_term_interest_rate': 'IR3TIB01CZM156N',
        'inflation': 'CPGRLE01CZM659N'
    },
    'Poland': {
        'gas_price_index': 'CP0452PLM086NEST',
        'short_term_interest_rate': 'IR3TIB01PLM156N',
        'inflation': 'CPGRLE01PLM659N'
    }
}

def fetch_fred_data(series_id, api_key, frequency):
    url = f'https://api.stlouisfed.org/fred/series/observations?series_id={series_id}&api_key={api_key}&file_type=json&frequency={frequency}'
    response = requests.get(url)
    response.raise_for_status()  # Raise an error for bad status codes
    data = response.json()
    return data['observations']

def convert_to_quarter_format(date_str):
    date = pd.to_datetime(date_str)
    quarter = (date.month - 1) // 3 + 1
    return f"{quarter}-{date.year}"

def convert_to_year_format(date_str):
    date = pd.to_datetime(date_str)
    return f"{date.year}"

def user_choose_frequency():
    while True:
        choice = input("Choose the data frequency (monthly, quarterly, yearly): ").strip().lower()
        if choice in ['m', 'monthly', 'q', 'quarterly', 'y', 'yearly']:
            return choice[0]
        else:
            print("Invalid choice. Please enter 'monthly', 'quarterly', or 'yearly'.")

def main():
    frequency_choice = user_choose_frequency()
    if frequency_choice == 'm':
        frequency = 'm'
        date_format_func = lambda x: x
    elif frequency_choice == 'q':
        frequency = 'q'
        date_format_func = convert_to_quarter_format
    elif frequency_choice == 'y':
        frequency = 'a'
        date_format_func = convert_to_year_format

    combined_data = []

    for country, series in countries.items():
        # Fetch and process data for gas price index
        gas_price_observations = fetch_fred_data(series['gas_price_index'], api_key, frequency)
        gas_price_df = pd.DataFrame(gas_price_observations)
        gas_price_df['date'] = gas_price_df['date'].apply(date_format_func)
        gas_price_df.rename(columns={'value': 'gas_price_index'}, inplace=True)

        # Fetch and process data for short term interest rate
        stir_observations = fetch_fred_data(series['short_term_interest_rate'], api_key, frequency)
        stir_df = pd.DataFrame(stir_observations)
        stir_df['date'] = stir_df['date'].apply(date_format_func)
        stir_df.rename(columns={'value': 'short_term_interest_rate'}, inplace=True)

        # Fetch and process data for inflation
        inflation_observations = fetch_fred_data(series['inflation'], api_key, frequency)
        inflation_df = pd.DataFrame(inflation_observations)
        inflation_df['date'] = inflation_df['date'].apply(date_format_func)
        inflation_df.rename(columns={'value': 'inflation'}, inplace=True)

        # Merge dataframes on country and date
        merged_df = gas_price_df.merge(stir_df, on='date').merge(inflation_df, on='date')
        merged_df['country'] = country

        combined_data.append(merged_df)

    # Combine all data frames into a single data frame
    combined_df = pd.concat(combined_data)

    # Reorder and rename columns for clarity
    combined_df = combined_df[['date', 'country', 'gas_price_index', 'short_term_interest_rate', 'inflation']]

    # Save to a CSV file
    combined_df.to_csv('full_country_economic_data.csv', index=False)

    print("Data has been saved to full_country_economic_data.csv")

if __name__ == '__main__':
    main()

import requests
import pandas as pd

# Your FRED API key
api_key = 'd726692257f21447103600d913230b26'  # Replace with your actual FRED API key

# Series IDs for economic variables by country
# These are hypothetical series IDs and should be replaced with actual IDs from FRED
countries = {
    'Austria':           {'gas_price_index': 'CP0452ATM086NEST', 'short_term_interest_rate': 'IR3TIB01ATM156N', 'inflation': 'CPGRLE01ATM659N'},
    'Belgium':           {'gas_price_index': 'CP0452BEM086NEST', 'short_term_interest_rate': 'IR3TIB01BEM156N', 'inflation': 'CPGRLE01BEM659N'},
    'Bulgaria':          {'gas_price_index': 'CP0452BGM086NEST', 'short_term_interest_rate': 'IR3TIB01BGM156N', 'inflation': 'CPGRLE01BGM659N'},
    'Croatia':           {'gas_price_index': 'CP0452HRM086NEST', 'short_term_interest_rate': 'IR3TIB01HRM156N', 'inflation': 'CPGRLE01HRM659N'},
    'Cyprus':            {'gas_price_index': 'CP0452CYM086NEST', 'short_term_interest_rate': 'IR3TIB01CYM156N', 'inflation': 'CPGRLE01CYM659N'},
    'Czechia':           {'gas_price_index': 'CP0452CZM086NEST', 'short_term_interest_rate': 'IR3TIB01CZM156N', 'inflation': 'CPGRLE01CZM659N'},
    'Denmark':           {'gas_price_index': 'CP0452DKM086NEST', 'short_term_interest_rate': 'IR3TIB01DKM156N', 'inflation': 'CPGRLE01DKM659N'},
    'Estonia':           {'gas_price_index': 'CP0452EEM086NEST', 'short_term_interest_rate': 'IR3TIB01EEM156N', 'inflation': 'CPGRLE01EEM659N'},
    'Finland':           {'gas_price_index': 'CP0452FIM086NEST', 'short_term_interest_rate': 'IR3TIB01FIM156N', 'inflation': 'CPGRLE01FIM659N'},
    'France':            {'gas_price_index': 'CP0452FRM086NEST', 'short_term_interest_rate': 'IR3TIB01FRM156N', 'inflation': 'CPGRLE01FRM659N'},
    'Germany':           {'gas_price_index': 'CP0452DEM086NEST', 'short_term_interest_rate': 'IR3TIB01DEM156N', 'inflation': 'CPGRLE01DEM659N'},
    'Greece':            {'gas_price_index': 'CP0452GRM086NEST', 'short_term_interest_rate': 'IR3TIB01GRM156N', 'inflation': 'CPGRLE01GRM659N'},
    'Hungary':           {'gas_price_index': 'CP0452HUM086NEST', 'short_term_interest_rate': 'IR3TIB01HUM156N', 'inflation': 'CPGRLE01HUM659N'},
    'Ireland':           {'gas_price_index': 'CP0452IRM086NEST', 'short_term_interest_rate': 'IR3TIB01IRM156N', 'inflation': 'CPGRLE01IRM659N'},
    'Italy':             {'gas_price_index': 'CP0452ITM086NEST', 'short_term_interest_rate': 'IR3TIB01ITM156N', 'inflation': 'CPGRLE01ITM659N'},
    'Latvia':            {'gas_price_index': 'CP0452LVM086NEST', 'short_term_interest_rate': 'LVAIR3TIB01STM', 'inflation': 'CPGRLE01LVM659N'},
    'Lithuania':         {'gas_price_index': 'CP0452LTM086NEST', 'short_term_interest_rate': 'LTUIR3TIB01STM', 'inflation': 'CPGRLE01LTM659N'},
    'Luxembourg':        {'gas_price_index': 'CP0452LUM086NEST', 'short_term_interest_rate': 'IR3TIB01LUM156N', 'inflation': 'CPGRLE01LUM659N'},
    'Malta':             {'gas_price_index': 'CP0452MTM086NEST', 'short_term_interest_rate': 'IR3TIB01MTM156N', 'inflation': 'CPGRLE01MTM659N'},
    'Netherlands':       {'gas_price_index': 'CP0452NLM086NEST', 'short_term_interest_rate': 'IR3TIB01NLM156N', 'inflation': 'CPGRLE01NLM659N'},
    'Poland':            {'gas_price_index': 'CP0452PLM086NEST', 'short_term_interest_rate': 'IR3TIB01PLM156N', 'inflation': 'CPGRLE01PLM659N'},
    'Portugal':          {'gas_price_index': 'CP0452PTM086NEST', 'short_term_interest_rate': 'IR3TIB01PTM156N', 'inflation': 'CPGRLE01PTM659N'},
    'Romania':           {'gas_price_index': 'CP0452ROM086NEST', 'short_term_interest_rate': 'IR3TIB01ROM156N', 'inflation': 'CPGRLE01ROM659N'},
    'Slovakia':          {'gas_price_index': 'CP0452SKM086NEST', 'short_term_interest_rate': 'IR3TIB01SKM156N', 'inflation': 'CPGRLE01SKM659N'},
    'Slovenia':          {'gas_price_index': 'CP0452SIM086NEST', 'short_term_interest_rate': 'IR3TIB01SIM156N', 'inflation': 'CPGRLE01SIM659N'},
    'Spain':             {'gas_price_index': 'CP0452ESM086NEST', 'short_term_interest_rate': 'IR3TIB01ESM156N', 'inflation': 'CPGRLE01ESM659N'},
    'Sweden':            {'gas_price_index': 'CP0452SEM086NEST', 'short_term_interest_rate': 'IR3TIB01SEM156N', 'inflation': 'CPGRLE01SEM659N'}
    # Add additional EU countries as needed.
}

def fetch_fred_data(series_id, api_key, frequency):
    url = f'https://api.stlouisfed.org/fred/series/observations?series_id={series_id}&api_key={api_key}&file_type=json&frequency={frequency}'
    response = requests.get(url)
    if response.status_code != 200:
        print(f"Invalid series ID: {series_id}")
        return None
    data = response.json()
    return data.get('observations', [])

def convert_to_quarter_format(date_str):
    date = pd.to_datetime(date_str)
    quarter = (date.month - 1) // 3 + 1
    return f'{quarter}-{date.year}'

def convert_to_year_format(date_str):
    date = pd.to_datetime(date_str)
    return f'{date.year}'

def user_choose_frequency():
    while True:
        choice = input("Choose the data frequency (monthly, quarterly, yearly): ").strip().lower()
        if choice in ['m', 'monthly', 'q', 'quarterly', 'y', 'yearly']:
            return choice[0]
        else:
            print("Invalid choice. Please enter 'monthly', 'quarterly', or 'yearly'.")

def main():
    frequency_choice = user_choose_frequency()
    if frequency_choice == 'm':
        frequency = 'm'
        date_format_func = lambda x: x
    elif frequency_choice == 'q':
        frequency = 'q'
        date_format_func = convert_to_quarter_format
    elif frequency_choice == 'y':
        frequency = 'a'
        date_format_func = convert_to_year_format

    combined_data = []

    for country, series in countries.items():
        print(f"Fetching data for {country}...")
        try:
            # Fetch and process data for gas price index
            gas_price_observations = fetch_fred_data(series['gas_price_index'], api_key, frequency)
            if not gas_price_observations:
                continue

            gas_price_df = pd.DataFrame(gas_price_observations)
            gas_price_df['date'] = gas_price_df['date'].apply(date_format_func)
            gas_price_df.rename(columns={'value': 'gas_price_index'}, inplace=True)

            # Fetch and process data for short term interest rate
            stir_observations = fetch_fred_data(series['short_term_interest_rate'], api_key, frequency)
            if not stir_observations:
                continue

            stir_df = pd.DataFrame(stir_observations)
            stir_df['date'] = stir_df['date'].apply(date_format_func)
            stir_df.rename(columns={'value': 'short_term_interest_rate'}, inplace=True)

            # Fetch and process data for inflation
            inflation_observations = fetch_fred_data(series['inflation'], api_key, frequency)
            if not inflation_observations:
                continue

            inflation_df = pd.DataFrame(inflation_observations)
            inflation_df['date'] = inflation_df['date'].apply(date_format_func)
            inflation_df.rename(columns={'value': 'inflation'}, inplace=True)

            # Merge dataframes on country and date
            merged_df = gas_price_df.merge(stir_df, on='date').merge(inflation_df, on='date')
            merged_df['country'] = country

            combined_data.append(merged_df)

        except Exception as e:
            print(f"An error occurred while processing data for {country}: {e}")

    if combined_data:
        # Combine all data frames into a single data frame
        combined_df = pd.concat(combined_data)

        # Reorder and rename columns for clarity
        combined_df = combined_df[['date', 'country', 'gas_price_index', 'short_term_interest_rate', 'inflation']]

        # Save to a CSV file
        combined_df.to_csv('full_country_economic_data.csv', index=False)

        print("Data has been saved to full_country_economic_data.csv")
    else:
        print("No valid data to save.")

if __name__ == '__main__':
    main()

import requests
import pandas as pd

# Your FRED API key
api_key = 'd726692257f21447103600d913230b26'  # Replace with your actual FRED API key

# Series IDs for economic variables by country
countries = {
    'Austria':           {'gas_price_index': 'CP0452ATM086NEST', 'short_term_interest_rate': 'IR3TIB01ATM156N', 'inflation': 'CPGRLE01ATM659N'},
    'Belgium':           {'gas_price_index': 'CP0452BEM086NEST', 'short_term_interest_rate': 'IR3TIB01BEM156N', 'inflation': 'CPGRLE01BEM659N'},
    'Bulgaria':          {'gas_price_index': 'CP0452BGM086NEST', 'short_term_interest_rate': 'IR3TIB01BGM156N', 'inflation': 'CPGRLE01BGM659N'},
    'Croatia':           {'gas_price_index': 'CP0452HRM086NEST', 'short_term_interest_rate': 'IR3TIB01HRM156N', 'inflation': 'CPGRLE01HRM659N'},
    'Cyprus':            {'gas_price_index': 'CP0452CYM086NEST', 'short_term_interest_rate': 'IR3TIB01CYM156N', 'inflation': 'CPGRLE01CYM659N'},
    'Czechia':           {'gas_price_index': 'CP0452CZM086NEST', 'short_term_interest_rate': 'IR3TIB01CZM156N', 'inflation': 'CPGRLE01CZM659N'},
    'Denmark':           {'gas_price_index': 'CP0452DKM086NEST', 'short_term_interest_rate': 'IR3TIB01DKM156N', 'inflation': 'CPGRLE01DKM659N'},
    'Estonia':           {'gas_price_index': 'CP0452EEM086NEST', 'short_term_interest_rate': 'IR3TIB01EEM156N', 'inflation': 'CPGRLE01EEM659N'},
    'Finland':           {'gas_price_index': 'CP0452FIM086NEST', 'short_term_interest_rate': 'IR3TIB01FIM156N', 'inflation': 'CPGRLE01FIM659N'},
    'France':            {'gas_price_index': 'CP0452FRM086NEST', 'short_term_interest_rate': 'IR3TIB01FRM156N', 'inflation': 'CPGRLE01FRM659N'},
    'Germany':           {'gas_price_index': 'CP0452DEM086NEST', 'short_term_interest_rate': 'IR3TIB01DEM156N', 'inflation': 'CPGRLE01DEM659N'},
    'Greece':            {'gas_price_index': 'CP0452GRM086NEST', 'short_term_interest_rate': 'IR3TIB01GRM156N', 'inflation': 'CPGRLE01GRM659N'},
    'Hungary':           {'gas_price_index': 'CP0452HUM086NEST', 'short_term_interest_rate': 'IR3TIB01HUM156N', 'inflation': 'CPGRLE01HUM659N'},
    'Ireland':           {'gas_price_index': 'CP0452IRM086NEST', 'short_term_interest_rate': 'IR3TIB01IRM156N', 'inflation': 'CPGRLE01IRM659N'},
    'Italy':             {'gas_price_index': 'CP0452ITM086NEST', 'short_term_interest_rate': 'IR3TIB01ITM156N', 'inflation': 'CPGRLE01ITM659N'},
    'Latvia':            {'gas_price_index': 'CP0452LVM086NEST', 'short_term_interest_rate': 'LVAIR3TIB01STM', 'inflation': 'CPGRLE01LVM659N'},
    'Lithuania':         {'gas_price_index': 'CP0452LTM086NEST', 'short_term_interest_rate': 'LTUIR3TIB01STM', 'inflation': 'CPGRLE01LTM659N'},
    'Luxembourg':        {'gas_price_index': 'CP0452LUM086NEST', 'short_term_interest_rate': 'IR3TIB01LUM156N', 'inflation': 'CPGRLE01LUM659N'},
    'Malta':             {'gas_price_index': 'CP0452MTM086NEST', 'short_term_interest_rate': 'IR3TIB01MTM156N', 'inflation': 'CPGRLE01MTM659N'},
    'Netherlands':       {'gas_price_index': 'CP0452NLM086NEST', 'short_term_interest_rate': 'IR3TIB01NLM156N', 'inflation': 'CPGRLE01NLM659N'},
    'Poland':            {'gas_price_index': 'CP0452PLM086NEST', 'short_term_interest_rate': 'IR3TIB01PLM156N', 'inflation': 'CPGRLE01PLM659N'},
    'Portugal':          {'gas_price_index': 'CP0452PTM086NEST', 'short_term_interest_rate': 'IR3TIB01PTM156N', 'inflation': 'CPGRLE01PTM659N'},
    'Romania':           {'gas_price_index': 'CP0452ROM086NEST', 'short_term_interest_rate': 'IR3TIB01ROM156N', 'inflation': 'CPGRLE01ROM659N'},
    'Slovakia':          {'gas_price_index': 'CP0452SKM086NEST', 'short_term_interest_rate': 'IR3TIB01SKM156N', 'inflation': 'CPGRLE01SKM659N'},
    'Slovenia':          {'gas_price_index': 'CP0452SIM086NEST', 'short_term_interest_rate': 'IR3TIB01SIM156N', 'inflation': 'CPGRLE01SIM659N'},
    'Spain':             {'gas_price_index': 'CP0452ESM086NEST', 'short_term_interest_rate': 'IR3TIB01ESM156N', 'inflation': 'CPGRLE01ESM659N'},
    'Sweden':            {'gas_price_index': 'CP0452SEM086NEST', 'short_term_interest_rate': 'IR3TIB01SEM156N', 'inflation': 'CPGRLE01SEM659N'}
    # Add additional EU countries as needed.
}

# List of oil and gas producing countries
oil_gas_producing_countries = ['Russia', 'Norway', 'United Kingdom', 'Netherlands', 'Denmark', 'Germany', 'Italy', 'Romania', 'Poland', 'Croatia', 'Ukraine']

def fetch_fred_data(series_id, api_key, frequency):
    url = f'https://api.stlouisfed.org/fred/series/observations?series_id={series_id}&api_key={api_key}&file_type=json&frequency={frequency}'
    response = requests.get(url)
    if response.status_code != 200:
        print(f"Invalid series ID: {series_id}")
        return None
    data = response.json()
    return data.get('observations', [])

def convert_to_quarter_format(date_str):
    date = pd.to_datetime(date_str)
    quarter = (date.month - 1) // 3 + 1
    return f'{quarter}-{date.year}'

def convert_to_year_format(date_str):
    date = pd.to_datetime(date_str)
    return f'{date.year}'

def user_choose_frequency():
    while True:
        choice = input("Choose the data frequency (monthly, quarterly, yearly): ").strip().lower()
        if choice in ['m', 'monthly', 'q', 'quarterly', 'y', 'yearly']:
            return choice[0]
        else:
            print("Invalid choice. Please enter 'monthly', 'quarterly', or 'yearly'.")

def user_exclude_oil_gas_producers():
    while True:
        choice = input("Do you want to exclude oil/gas producing countries? (yes/no): ").strip().lower()
        if choice in ['yes', 'no']:
            return choice == 'yes'
        else:
            print("Invalid choice. Please enter 'yes' or 'no'.")

def main():
    frequency_choice = user_choose_frequency()
    exclude_oil_gas = user_exclude_oil_gas_producers()

    if exclude_oil_gas:
        filtered_countries = {k: v for k, v in countries.items() if k not in oil_gas_producing_countries}
    else:
        filtered_countries = countries

    if frequency_choice == 'm':
        frequency = 'm'
        date_format_func = lambda x: x
    elif frequency_choice == 'q':
        frequency = 'q'
        date_format_func = convert_to_quarter_format
    elif frequency_choice == 'y':
        frequency = 'a'
        date_format_func = convert_to_year_format

    combined_data = []

    for country, series in filtered_countries.items():
        print(f"Fetching data for {country}...")
        try:
            # Fetch and process data for gas price index
            gas_price_observations = fetch_fred_data(series['gas_price_index'], api_key, frequency)
            if not gas_price_observations:
                continue

            gas_price_df = pd.DataFrame(gas_price_observations)
            gas_price_df['time'] = gas_price_df['date'].apply(date_format_func)
            gas_price_df.rename(columns={'value': 'gas_price_index'}, inplace=True)

            # Fetch and process data for short term interest rate
            stir_observations = fetch_fred_data(series['short_term_interest_rate'], api_key, frequency)
            if not stir_observations:
                continue

            stir_df = pd.DataFrame(stir_observations)
            stir_df['time'] = stir_df['date'].apply(date_format_func)
            stir_df.rename(columns={'value': 'short_term_interest_rate'}, inplace=True)

            # Fetch and process data for inflation
            inflation_observations = fetch_fred_data(series['inflation'], api_key, frequency)
            if not inflation_observations:
                continue

            inflation_df = pd.DataFrame(inflation_observations)
            inflation_df['time'] = inflation_df['date'].apply(date_format_func)
            inflation_df.rename(columns={'value': 'inflation'}, inplace=True)

            # Merge dataframes on country and time
            merged_df = gas_price_df.merge(stir_df, on='time').merge(inflation_df, on='time')
            merged_df['country'] = country

            combined_data.append(merged_df)

        except Exception as e:
            print(f"An error occurred while processing data for {country}: {e}")

    if combined_data:
        # Combine all data frames into a single data frame
        combined_df = pd.concat(combined_data)

        # Reorder and rename columns for clarity
        combined_df = combined_df[['time', 'country', 'gas_price_index', 'short_term_interest_rate', 'inflation']]

        # Save to a CSV file
        combined_df.to_csv('full_country_economic_data.csv', index=False)

        print("Data has been saved to full_country_economic_data.csv")
    else:
        print("No valid data to save.")

if __name__ == '__main__':
      main()

import requests
import pandas as pd

# Your FRED API key
api_key = 'd726692257f21447103600d913230b26'  # Replace with your actual FRED API key

# Series IDs for economic variables by country
countries = {
    'Austria':           {'gas_price_index': 'CP0452ATM086NEST', 'short_term_interest_rate': 'IR3TIB01ATM156N', 'inflation': 'CPGRLE01ATM659N'},
    'Belgium':           {'gas_price_index': 'CP0452BEM086NEST', 'short_term_interest_rate': 'IR3TIB01BEM156N', 'inflation': 'CPGRLE01BEM659N'},
    'Bulgaria':          {'gas_price_index': 'CP0452BGM086NEST', 'short_term_interest_rate': 'IR3TIB01BGM156N', 'inflation': 'CPGRLE01BGM659N'},
    'Croatia':           {'gas_price_index': 'CP0452HRM086NEST', 'short_term_interest_rate': 'IR3TIB01HRM156N', 'inflation': 'CPGRLE01HRM659N'},
    'Cyprus':            {'gas_price_index': 'CP0452CYM086NEST', 'short_term_interest_rate': 'IR3TIB01CYM156N', 'inflation': 'CPGRLE01CYM659N'},
    'Czechia':           {'gas_price_index': 'CP0452CZM086NEST', 'short_term_interest_rate': 'IR3TIB01CZM156N', 'inflation': 'CPGRLE01CZM659N'},
    'Denmark':           {'gas_price_index': 'CP0452DKM086NEST', 'short_term_interest_rate': 'IR3TIB01DKM156N', 'inflation': 'CPGRLE01DKM659N'},
    'Estonia':           {'gas_price_index': 'CP0452EEM086NEST', 'short_term_interest_rate': 'IR3TIB01EEM156N', 'inflation': 'CPGRLE01EEM659N'},
    'Finland':           {'gas_price_index': 'CP0452FIM086NEST', 'short_term_interest_rate': 'IR3TIB01FIM156N', 'inflation': 'CPGRLE01FIM659N'},
    'France':            {'gas_price_index': 'CP0452FRM086NEST', 'short_term_interest_rate': 'IR3TIB01FRM156N', 'inflation': 'CPGRLE01FRM659N'},
    'Germany':           {'gas_price_index': 'CP0452DEM086NEST', 'short_term_interest_rate': 'IR3TIB01DEM156N', 'inflation': 'CPGRLE01DEM659N'},
    'Greece':            {'gas_price_index': 'CP0452GRM086NEST', 'short_term_interest_rate': 'IR3TIB01GRM156N', 'inflation': 'CPGRLE01GRM659N'},
    'Hungary':           {'gas_price_index': 'CP0452HUM086NEST', 'short_term_interest_rate': 'IR3TIB01HUM156N', 'inflation': 'CPGRLE01HUM659N'},
    'Ireland':           {'gas_price_index': 'CP0452IRM086NEST',        'short_term_interest_rate': 'IR3TIB01IRM156N', 'inflation': 'CPGRLE01IRM659N'},
    'Italy':             {'gas_price_index': 'CP0452ITM086NEST', 'short_term_interest_rate': 'IR3TIB01ITM156N', 'inflation': 'CPGRLE01ITM659N'},
    'Latvia':            {'gas_price_index': 'CP0452LVM086NEST', 'short_term_interest_rate': 'LVAIR3TIB01STM', 'inflation': 'CPGRLE01LVM659N'},
    'Lithuania':         {'gas_price_index': 'CP0452LTM086NEST', 'short_term_interest_rate': 'LTUIR3TIB01STM', 'inflation': 'CPGRLE01LTM659N'},
    'Luxembourg':        {'gas_price_index': 'CP0452LUM086NEST', 'short_term_interest_rate': 'IR3TIB01LUM156N', 'inflation': 'CPGRLE01LUM659N'},
    'Malta':             {'gas_price_index': 'CP0452MTM086NEST', 'short_term_interest_rate': 'IR3TIB01MTM156N', 'inflation': 'CPGRLE01MTM659N'},
    'Netherlands':       {'gas_price_index': 'CP0452NLM086NEST', 'short_term_interest_rate': 'IR3TIB01NLM156N', 'inflation': 'CPGRLE01NLM659N'},
    'Poland':            {'gas_price_index': 'CP0452PLM086NEST', 'short_term_interest_rate': 'IR3TIB01PLM156N', 'inflation': 'CPGRLE01PLM659N'},
    'Portugal':          {'gas_price_index': 'CP0452PTM086NEST', 'short_term_interest_rate': 'IR3TIB01PTM156N', 'inflation': 'CPGRLE01PTM659N'},
    'Romania':           {'gas_price_index': 'CP0452ROM086NEST', 'short_term_interest_rate': 'IR3TIB01ROM156N', 'inflation': 'CPGRLE01ROM659N'},
    'Slovakia':          {'gas_price_index': 'CP0452SKM086NEST', 'short_term_interest_rate': 'IR3TIB01SKM156N', 'inflation': 'CPGRLE01SKM659N'},
    'Slovenia':          {'gas_price_index': 'CP0452SIM086NEST', 'short_term_interest_rate': 'IR3TIB01SIM156N', 'inflation': 'CPGRLE01SIM659N'},
    'Spain':             {'gas_price_index': 'CP0452ESM086NEST', 'short_term_interest_rate': 'IR3TIB01ESM156N', 'inflation': 'CPGRLE01ESM659N'},
    'Sweden':            {'gas_price_index': 'CP0452SEM086NEST', 'short_term_interest_rate': 'IR3TIB01SEM156N', 'inflation': 'CPGRLE01SEM659N'}
    # Add additional EU countries as needed.
}

# List of oil and gas producing countries
oil_gas_producing_countries = ['Russia', 'Norway', 'United Kingdom', 'Netherlands', 'Denmark', 'Germany', 'Italy', 'Romania', 'Poland', 'Croatia', 'Ukraine']

def fetch_fred_data(series_id, api_key, frequency):
    url = f'https://api.stlouisfed.org/fred/series/observations?series_id={series_id}&api_key={api_key}&file_type=json&frequency={frequency}'
    response = requests.get(url)
    if response.status_code != 200:
        print(f"Invalid series ID: {series_id}")
        return None
    data = response.json()
    return data.get('observations', [])

def convert_to_quarter_format(date_str):
    date = pd.to_datetime(date_str)
    quarter = (date.month - 1) // 3 + 1
    return f'{quarter}-{date.year}'

def convert_to_year_format(date_str):
    date = pd.to_datetime(date_str)
    return f'{date.year}'

def user_choose_frequencies():
    while True:
        choice = input("Choose the data frequencies to save (m for monthly, q for quarterly, y for yearly, use commas to separate multiple choices): ").strip().lower()
        choices = [c.strip() for c in choice.split(',') if c.strip() in ['m', 'q', 'y']]
        if choices:
            return choices
        else:
            print("Invalid choices. Please enter 'm', 'q', and/or 'y', separated by commas as needed.")

def user_exclude_oil_gas_producers():
    while True:
        choice = input("Do you want to exclude oil/gas producing countries? (yes/no): ").strip().lower()
        if choice in ['yes', 'no']:
            return choice == 'yes'
        else:
            print("Invalid choice. Please enter 'yes' or 'no'.")

def main():
    frequency_choices = user_choose_frequencies()
    exclude_oil_gas = user_exclude_oil_gas_producers()

    if exclude_oil_gas:
        filtered_countries = {k: v for k, v in countries.items() if k not in oil_gas_producing_countries}
    else:
        filtered_countries = countries

    combined_data = []

    for country, series in filtered_countries.items():
        print(f"Fetching data for {country}...")
        try:
            for frequency_choice in frequency_choices:
                if frequency_choice == 'm':
                    frequency = 'm'
                    date_format_func = lambda x: x
                elif frequency_choice == 'q':
                    frequency = 'q'
                    date_format_func = convert_to_quarter_format
                elif frequency_choice == 'y':
                    frequency = 'a'
                    date_format_func = convert_to_year_format

                # Fetch and process data for gas price index
                gas_price_observations = fetch_fred_data(series['gas_price_index'], api_key, frequency)
                if not gas_price_observations:
                    continue

                gas_price_df = pd.DataFrame(gas_price_observations)
                gas_price_df['time'] = gas_price_df['date'].apply(date_format_func)
                gas_price_df.rename(columns={'value': 'gas_price_index'}, inplace=True)

                # Fetch and process data for short term interest rate
                stir_observations = fetch_fred_data(series['short_term_interest_rate'], api_key, frequency)
                if not stir_observations:
                    continue

                stir_df = pd.DataFrame(stir_observations)
                stir_df['time'] = stir_df['date'].apply(date_format_func)
                stir_df.rename(columns={'value': 'short_term_interest_rate'}, inplace=True)

                # Fetch and process data for inflation
                inflation_observations = fetch_fred_data(series['inflation'], api_key, frequency)
                if not inflation_observations:
                    continue

                inflation_df = pd.DataFrame(inflation_observations)
                inflation_df['time'] = inflation_df['date'].apply(date_format_func)
                inflation_df.rename(columns={'value': 'inflation'}, inplace=True)

                # Merge dataframes on country and time
                merged_df = gas_price_df.merge(stir_df, on='time').merge(inflation_df, on='time')
                merged_df['country'] = country
                merged_df['frequency'] = frequency_choice

                combined_data.append(merged_df)

        except Exception as e:
            print(f"An error occurred while processing data for {country}: {e}")

    if combined_data:
        # Combine all data frames into a single data frame
        combined_df = pd.concat(combined_data, ignore_index=True)

        # Reorder and rename columns for clarity
        combined_df = combined_df[['time', 'country', 'frequency', 'gas_price_index', 'short_term_interest_rate', 'inflation']]

        # Save to a CSV file
        combined_df.to_csv('full_country_economic_data.csv', index=False)

        print("Data has been saved to full_country_economic_data.csv")
    else:
        print("No valid data to save.")

if __name__ == '__main__':
    main()

import pandas as pd

def consolidate_csv_files(file1, file2, file3):
    # Read the CSV files into DataFrames
    df1 = pd.read_csv(file1)
    df2 = pd.read_csv(file2)
    df3 = pd.read_csv(file3)

    # Create a key column by concatenating "country" and "time" columns
    df1['key'] = df1['country'].astype(str) + df1['time'].astype(str)
    df2['key'] = df2['country'].astype(str) + df2['time'].astype(str)
    df3['key'] = df3['country'].astype(str) + df3['time'].astype(str)

    # Set the key column as the index for merging
    df1.set_index('key', inplace=True)
    df2.set_index('key', inplace=True)
    df3.set_index('key', inplace=True)

    # Remove the country and time columns to avoid duplication
    df1.drop(columns=['country', 'time'], inplace=True)
    df2.drop(columns=['country', 'time'], inplace=True)
    df3.drop(columns=['country', 'time'], inplace=True)

    # Rename the columns to indicate their origin
    df1.columns = [f"{col}_df1" for col in df1.columns]
    df2.columns = [f"{col}_df2" for col in df2.columns]
    df3.columns = [f"{col}_df3" for col in df3.columns]

    # Merge the DataFrames on the index
    consolidated_df = df1.join(df2, how='outer').join(df3, how='outer')

    # Reset index to turn the index back into columns
    consolidated_df.reset_index(inplace=True)

    # Split the key back into country and time columns
    #consolidated_df['country'] = consolidated_df['key'].apply(lambda x: x[:-1])  # Assumes last character is time
    #consolidated_df['time'] = consolidated_df['key'].apply(lambda x: x[-1])  # Assumes last character is time

    # Reorder columns to put country and time at the beginning
    cols = ['country', 'time'] + [col for col in consolidated_df.columns if col not in ['country', 'time', 'key']]
    consolidated_df = consolidated_df[cols]

    # Drop the 'key' column as it is no longer needed
    #consolidated_df.drop(columns=['key'], inplace=True)

    return consolidated_df

# Usage
file1 = 'Consolidated Electricity Production File.csv'
file2 = 'Consolidated Employment Data.csv'
file3 = 'full_country_economic_data.csv'

# Consolidate the files
consolidated_df = consolidate_csv_files(file1, file2, file3)

# Save consolidated data to a new CSV file
consolidated_df.to_csv('consolidated_data.csv', index=False)

print("Consolidated data saved to 'consolidated_data.csv'.")

import pandas as pd
import re

def convert_date_format(date_str):
    if 'quarter' in date_str:
        match = re.match(r'quarter (\d{4})Q(\d)', date_str)
        if match:
            year, quarter = match.groups()
            return f"quarter {quarter}-{year}"
    elif 'month' in date_str:
        match = re.match(r'month (\d{4})M(\d{2})', date_str)
        if match:
            year, month = match.groups()
            return f"month {month}/1/{year}"
        match = re.match(r'month (\d{4})-(\d{2})', date_str)
        if match:
            year, month = match.groups()
            return f"month {month}/1/{year}"
    return date_str

def infer_data_type(date_str):
    if re.match(r'quarter \d-\d{4}', date_str):
        return 'quarterly'
    elif re.match(r'month \d{1,2}/1/\d{4}', date_str):
        return 'monthly'
    else:
        return 'annual'

def consolidate_csv_files(file1, file2, file3):
    # Read the CSV files into DataFrames
    df1 = pd.read_csv(file1)
    df2 = pd.read_csv(file2)
    df3 = pd.read_csv(file3)

    # Debugging: Print initial data
    print("Initial DataFrames:\n")
    print(df1.head())
    print(df2.head())
    print(df3.head())

    # Apply the date conversion to the time column
    df1['time'] = df1['time'].apply(convert_date_format)
    df2['time'] = df2['time'].apply(convert_date_format)
    df3['time'] = df3['time'].apply(convert_date_format)

    # Debugging: Print data after date conversion
    print("\nData after date conversion:\n")
    print(df1.head())
    print(df2.head())
    print(df3.head())

    # Infer the type of data in each DataFrame and store it in a new column
    df1['data_type'] = df1['time'].apply(infer_data_type)
    df2['data_type'] = df2['time'].apply(infer_data_type)
    df3['data_type'] = df3['time'].apply(infer_data_type)

    # Create a key based on 'country' and 'time'
    df1['key'] = df1['country'].astype(str) + "-" + df1['time']
    df2['key'] = df2['country'].astype(str) + "-" + df2['time']
    df3['key'] = df3['country'].astype(str) + "-" + df3['time']

    # Debugging: Print data with keys
    print("\nData with keys:\n")
    print(df1.head())
    print(df2.head())
    print(df3.head())

    # Set the key column as the index for merging, and drop the original 'country' and 'time' columns
    for df, name in zip([df1, df2, df3], ['df1', 'df2', 'df3']):
        df.set_index('key', inplace=True)
        df.drop(columns=['country', 'time'], inplace=True)
        df.columns = [f"{col}_{name}" for col in df.columns]

    # Merge the DataFrames on the 'key'
    consolidated_df = df1.join(df2, how='outer').join(df3, how='outer')

    # Reset the index
    consolidated_df.reset_index(inplace=True)

    # Debugging: Print consolidated data
    print("\nConsolidated DataFrame:\n")
    print(consolidated_df.head())

    # Ask the user for their preference
    choice = input("Do you want to consolidate and keep (monthly / quarterly / annual) data only?: ").strip().lower()

    # Filter Data Based on User Choice
    if choice == 'monthly':
        consolidated_df = consolidated_df[consolidated_df.apply(lambda row: any('monthly' in (str(row[col]) if not pd.isna(row[col]) else '') for col in consolidated_df.columns if 'data_type' in col), axis=1)]
    elif choice == 'quarterly':
        consolidated_df = consolidated_df[consolidated_df.apply(lambda row: any('quarterly' in (str(row[col]) if not pd.isna(row[col]) else '') for col in consolidated_df.columns if 'data_type' in col), axis=1)]
    elif choice == 'annual':
        consolidated_df['year'] = consolidated_df['key'].str.extract(r'(\d{4})', expand=False)
        consolidated_df = consolidated_df.drop_duplicates(subset=['year']).drop(columns=['year'])

    # Drop the 'key' column
    consolidated_df.drop(columns=['key'], inplace=True)

    # Drop the intermediate 'data_type' columns
    data_type_cols = [col for col in consolidated_df.columns if 'data_type' in col]
    consolidated_df.drop(columns=data_type_cols, inplace=True)

    return consolidated_df

# Usage
file1 = 'Consolidated_Electricity_Production_File_Formatted.csv'
file2 = 'Consolidated_Employment_Data_Formatted.csv'
file3 = 'full_country_economic_data.csv'

# Consolidate the files
consolidated_df = consolidate_csv_files(file1, file2, file3)

# Save consolidated data to a new CSV file
consolidated_df.to_csv('consolidated_data.csv', index=False)

print("Consolidated data saved to 'consolidated_data.csv'.")

import pandas as pd
import re

def convert_date_format(date_str):
    if re.match(r'\d{4}', date_str):  # Yearly format (e.g., "1999")
        return date_str
    elif re.match(r'quarter \d{1}-\d{4}', date_str):  # Already correct quarterly format
        return date_str
    elif re.match(r'month \d{1,2}/1/\d{4}', date_str):  # Already correct monthly format
        return date_str
    elif 'quarter' in date_str:
        match = re.match(r'quarter (\d{4})Q(\d)', date_str)
        if match:
            year, quarter = match.groups()
            return f"quarter {quarter}-{year}"
    elif 'month' in date_str:
        match = re.match(r'month (\d{4})M(\d{2})', date_str)
        if match:
            year, month = match.groups()
            return f"month {month}/1/{year}"
        match = re.match(r'month (\d{4})-(\d{2})', date_str)
        if match:
            year, month = match.groups()
            return f"month {month}/1/{year}"
    return date_str  # Return unchanged if it doesn't match any known patterns

def fix_time_column(filepath, output_filepath):
    # Read the CSV file into a DataFrame
    df = pd.read_csv(filepath)

    # Debugging: Print initial data
    print("Initial DataFrame:\n")
    print(df.head())

    # Convert the time column
    if 'time' in df.columns:
        df['time'] = df['time'].apply(convert_date_format)

    # Debugging: Print data after date conversion
    print("\nDataFrame after date conversion:\n")
    print(df.head())

    # Save the fixed DataFrame to a new CSV file
    df.to_csv(output_filepath, index=False)
    print(f"\nFixed data saved to '{output_filepath}'.")

# Usage
input_file = 'Consolidated Employment Data.csv'
output_file = 'Consolidated_Employment_Data_Formatted.csv'

# Fix the time column
fix_time_column(input_file, output_file)

import pandas as pd
import re

def convert_date_format(date_str):
    if re.match(r'^\d{4}$', date_str):  # Yearly format (e.g., "1999")
        return date_str
    elif re.match(r'^\d{1}-\d{4}$', date_str):  # Correctly formatted quarterly format (e.g., "3-1999")
        return date_str
    elif re.match(r'^\d{4}-\d{2}-\d{2}$', date_str):  # Correctly formatted monthly format (e.g., "1999-12-01")
        return date_str
    elif re.match(r'^\d{4}-\d{2}$', date_str):  # Monthly format (e.g., "1999-12")
        return f"{date_str}-01"
    elif 'quarter' in date_str:
        match = re.match(r'quarter (\d{4})Q(\d)', date_str)
        if match:
            year, quarter = match.groups()
            return f"{quarter}-{year}"
    elif 'month' in date_str:
        match = re.match(r'month (\d{4})M(\d{2})', date_str)
        if match:
            year, month = match.groups()
            return f"{year}-{month.zfill(2)}-01"  # Format as YYYY-MM-DD
        match = re.match(r'month (\d{4})-(\d{2})', date_str)
        if match:
            year, month = match.groups()
            return f"{year}-{month.zfill(2)}-01"  # Format as YYYY-MM-DD
    elif re.match(r'^\d{4}Q\d$', date_str):  # Handle "YYYYQX" format for quarters (e.g., "2021Q3")
        match = re.match(r'(\d{4})Q(\d)', date_str)
        if match:
            year, quarter = match.groups()
            return f"{quarter}-{year}"
    elif re.match(r'^\d{4}M\d{2}$', date_str):  # Handle "YYYYMXX" format for months (e.g., "2021M12")
        match = re.match(r'(\d{4})M(\d{2})', date_str)
        if match:
            year, month = match.groups()
            return f"{year}-{month.zfill(2)}-01"  # Format as YYYY-MM-DD
    return date_str  # Return unchanged if it doesn't match any known patterns

def fix_time_column(filepath, output_filepath):
    # Read the CSV file into a DataFrame
    df = pd.read_csv(filepath)

    # Debugging: Print initial data
    print("Initial DataFrame:\n")
    print(df.head())

    # Convert the time column
    if 'time' in df.columns:
        df['time'] = df['time'].apply(convert_date_format)

    # Debugging: Print data after date conversion
    print("\nDataFrame after date conversion:\n")
    print(df.head())

    # Save the fixed DataFrame to a new CSV file
    df.to_csv(output_filepath, index=False)
    print(f"\nFixed data saved to '{output_filepath}'.")

# Usage
#input_file = 'Consolidated Employment Data.csv'
input_file = 'Consolidated Electricity Production File.csv'
output_file = 'Consolidated_Electricity_Production_File_Formatted.csv'

#output_file = 'Consolidated_Employment_Data_Formatted.csv'

# Fix the time column
fix_time_column(input_file, output_file)

import pandas as pd
import re

def convert_date_format(date_str):
    if re.match(r'^\d{4}$', date_str):  # Yearly format (e.g., "1999")
        return date_str
    elif re.match(r'^\d{1}-\d{4}$', date_str):  # Correctly formatted quarterly format (e.g., "3-1999")
        return date_str
    elif re.match(r'^\d{4}-\d{2}-\d{2}$', date_str):  # Correctly formatted monthly format (e.g., "1999-12-01")
        return date_str
    elif re.match(r'^\d{1,2}-\d{4}$', date_str):  # Month-year format (e.g., "12-1999")
        return f"{date_str}-01"
    elif 'quarter' in date_str:
        match = re.match(r'quarter (\d{4})Q(\d)', date_str)  # Handle "quarter YYYYQX"
        if match:
            year, quarter = match.groups()
            return f"{quarter}-{year}"
    elif 'month' in date_str:
        match = re.match(r'month (\d{4})M(\d{2})', date_str)  # Handle "month YYYYMX"
        if match:
            year, month = match.groups()
            return f"{year}-{month.zfill(2)}-01"  # Format as YYYY-MM-DD
        match = re.match(r'month (\d{4})-(\d{2})', date_str)  # Handle "month YYYY-MM"
        if match:
            year, month = match.groups()
            return f"{year}-{month.zfill(2)}-01"  # Format as YYYY-MM-DD
    elif re.match(r'^\d{4}Q\d$', date_str):  # Handle "YYYYQX" format for quarters
        match = re.match(r'(\d{4})Q(\d)', date_str)
        if match:
            year, quarter = match.groups()
            return f"{quarter}-{year}"
    elif re.match(r'^\d{4}-\d{2}$', date_str):  # Handle "YYYY-MM" format for months (e.g., "2021-12")
        match = re.match(r'(\d{4})-(\d{2})', date_str)
        if match:
            year, month = match.groups()
            return f"{year}-{month.zfill(2)}-01"  # Format as YYYY-MM-DD
    elif re.match(r'^\d{4}M\d{2}$', date_str):  # Handle "YYYYMXX" format for months (e.g., "2021M12")
        match = re.match(r'(\d{4})M(\d{2})', date_str)
        if match:
            year, month = match.groups()
            return f"{year}-{month.zfill(2)}-01"  # Format as YYYY-MM-DD
    return date_str  # Return unchanged if it doesn't match any known patterns

def fix_time_column(filepath, output_filepath):
    # Read the CSV file into a DataFrame
    df = pd.read_csv(filepath)

    # Debugging: Print initial data
    print("Initial DataFrame:\n")
    print(df.head())

    # Convert the time column
    if 'time' in df.columns:
        df['time'] = df['time'].apply(convert_date_format)

    # Debugging: Print data after date conversion
    print("\nDataFrame after date conversion:\n")
    print(df.head())

    # Save the fixed DataFrame to a new CSV file
    df.to_csv(output_filepath, index=False)
    print(f"\nFixed data saved to '{output_filepath}'.")

# Usage
#input_file = 'Consolidated Employment Data.csv'
input_file = 'Consolidated Electricity Production File.csv'
output_file = 'Consolidated_Electricity_Production_File_Formatted.csv'

#output_file = 'Consolidated_Employment_Data_Formatted.csv'

# Fix the time column
fix_time_column(input_file, output_file)

import pandas as pd
import re

# Function to normalize time format to a unique standard form
def normalize_time(time_str):
    if re.match(r'^\d{4}$', time_str):  # Yearly format (e.g., "1999")
        return time_str
    elif re.match(r'^\d{1}-\d{4}$', time_str):  # Quarterly format (e.g., "1-1999")
        return time_str
    elif re.match(r'^\d{4}-\d{2}-\d{2}$', time_str):  # Monthly format (e.g., "1999-12-01")
        return time_str
    elif re.match(r'^\d{4}-\d{2}$', time_str):  # Monthly format without day (e.g., "1999-12")
        return f"{time_str}-01"
    else:
        raise ValueError(f"Unrecognized time format: {time_str}")

# Function to infer the data type from the normalized time string
def infer_data_type(time_str):
    if re.match(r'^\d{4}$', time_str):
        return 'annual'
    elif re.match(r'^\d{1}-\d{4}$', time_str):
        return 'quarterly'
    elif re.match(r'^\d{4}-\d{2}-\d{2}$', time_str):
        return 'monthly'
    else:
        return 'unknown'

# Function to process each DataFrame
def process_dataframe(df, name):
    df['time'] = df['time'].apply(normalize_time)
    df['key'] = df['country'] + '-' + df['time']
    df['data_type'] = df['time'].apply(infer_data_type)
    df.set_index('key', inplace=True)
    df.drop(columns=['country', 'time'], inplace=True)
    df.columns = [f"{col}_{name}" for col in df.columns]
    return df

# Function to consolidate the CSV files
def consolidate_csv_files(file1, file2, file3):
    # Read the CSV files into DataFrames
    df1 = pd.read_csv(file1)
    df2 = pd.read_csv(file2)
    df3 = pd.read_csv(file3)

    # Process each DataFrame
    df1 = process_dataframe(df1, 'df1')
    df2 = process_dataframe(df2, 'df2')
    df3 = process_dataframe(df3, 'df3')

    # Merge the DataFrames on the key
    consolidated_df = df1.join(df2, how='outer').join(df3, how='outer')

    # Reset the index
    consolidated_df.reset_index(inplace=True)

    # Ask the user for their preference
    choice = input("Do you want to consolidate and keep (annual / quarterly / monthly) data only?: ").strip().lower()

    # Filter Data Based on User Choice
    if choice in ['annual', 'quarterly', 'monthly']:
        consolidated_df = consolidated_df[consolidated_df.apply(
            lambda row: any(row[col] == choice for col in consolidated_df.columns if 'data_type' in col), axis=1)]
    else:
        print(f"{choice} is not a valid option. Keeping all data.")

    # Drop the intermediate 'data_type' columns
    data_type_cols = [col for col in consolidated_df.columns if 'data_type' in col]
    consolidated_df.drop(columns=data_type_cols, inplace=True)

    return consolidated_df

# Example usage
file1 = 'Consolidated_Electricity_Production_File_Formatted.csv'
file2 = 'Consolidated_Employment_Data_Formatted.csv'
file3 = 'full_country_economic_data.csv'

# Consolidate the files
consolidated_df = consolidate_csv_files(file1, file2, file3)

# Save consolidated data to a new CSV file
consolidated_df.to_csv('consolidated_data.csv', index=False)
print("Consolidated data saved to 'consolidated_data.csv'.")

import pandas as pd
import re

# Function to normalize time format to a unique standard form
def normalize_time(time_str):
    if re.match(r'^\d{4}$', time_str):  # Yearly format (e.g., "1999")
        return time_str
    elif re.match(r'^\d{1}-\d{4}$', time_str):  # Quarterly format (e.g., "1-1999")
        return time_str
    elif re.match(r'^\d{4}-\d{2}-\d{2}$', time_str):  # Monthly format (e.g., "1999-12-01")
        return time_str
    elif re.match(r'^\d{4}-\d{2}$', time_str):  # Monthly format without day (e.g., "1999-12")
        return f"{time_str}-01"
    else:
        raise ValueError(f"Unrecognized time format: {time_str}")

# Function to infer the data type from the normalized time string
def infer_data_type(time_str):
    if re.match(r'^\d{4}$', time_str):
        return 'annual'
    elif re.match(r'^\d{1}-\d{4}$', time_str):
        return 'quarterly'
    elif re.match(r'^\d{4}-\d{2}-\d{2}$', time_str):
        return 'monthly'
    else:
        return 'unknown'

# Function to process each DataFrame
def process_dataframe(df, name):
    df['normalized_time'] = df['time'].apply(normalize_time)
    df['key'] = df['country'] + '-' + df['normalized_time']
    df['data_type'] = df['normalized_time'].apply(infer_data_type)
    df.set_index('key', inplace=True)
    df.columns = [f"{col}_{name}" if col not in ['country', 'time', 'normalized_time'] else col for col in df.columns]
    return df

# Function to consolidate the CSV files
def consolidate_csv_files(file1, file2, file3):
    # Read the CSV files into DataFrames
    df1 = pd.read_csv(file1)
    df2 = pd.read_csv(file2)
    df3 = pd.read_csv(file3)

    # Process each DataFrame
    df1 = process_dataframe(df1, 'df1')
    df2 = process_dataframe(df2, 'df2')
    df3 = process_dataframe(df3, 'df3')

    # Merge the DataFrames on the key, keeping country and time columns from the first DataFrame
    merged_df = df1.join(df2, how='outer', rsuffix='_df2').join(df3, how='outer', rsuffix='_df3')

    # Reset the index
    merged_df.reset_index(inplace=True)

    # Ask the user for their preference
    choice = input("Do you want to consolidate and keep (annual / quarterly / monthly) data only?: ").strip().lower()

    # Filter Data Based on User Choice
    if choice in ['annual', 'quarterly', 'monthly']:
        merged_df = merged_df[merged_df.apply(
            lambda row: any(row[col] == choice for col in merged_df.columns if 'data_type' in col), axis=1)]
    else:
        print(f"{choice} is not a valid option. Keeping all data.")

    # Drop the intermediate 'data_type' and 'normalized_time' columns
    data_type_cols = [col for col in merged_df.columns if 'data_type' in col]
    normalized_time_cols = [col for col in merged_df.columns if 'normalized_time' in col]
    merged_df.drop(columns=data_type_cols + normalized_time_cols, inplace=True)

    return merged_df

# Example usage
file1 = 'Consolidated_Electricity_Production_File_Formatted.csv'
file2 = 'Consolidated_Employment_Data_Formatted.csv'
file3 = 'full_country_economic_data.csv'

# Consolidate the files
consolidated_df = consolidate_csv_files(file1, file2, file3)

# Save consolidated data to a new CSV file
consolidated_df.to_csv('consolidated_data.csv', index=False)
print("Consolidated data saved to 'consolidated_data.csv'.")